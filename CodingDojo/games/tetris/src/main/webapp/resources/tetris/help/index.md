<header class="entry-header">
<h1 class="entry-title">Tetris codenjoy — как играть? <a target="_self" href="index-en.html">[EN]</a> </h1>
</header>

<div class="entry-content">
<div class="page-restrict-output">

<h2>В чем суть игры?</h2>

<p>Надо написать своего бота, который обыграет других ботов
по очкам в тетрис.</p>

<p>Каждый участник играет на своем поле. Играющий может
двигать фигуркой влево и вправо, вращать ее и приземлять.
Все так же, как в классическом тетрисе с одной лишь разницей - фигурки
появляются не сразу: как только ты научишься укладывать "квадратики",
появятся "палочки" и так далее, пока тебе не откроются все фигурки.</p>

<p>Чем дальше ты заходишь, тем больше очков зарабатываешь.
Чтобы перейти на следующий уровень тебе необходимо укладывать
фигурки компактно, чтобы образовывались сплошные линии (от стенки к стенке),
которые затем "снимаются" (удаляются) с начислением бонусных очков.</p>

<h2>Регистрация и клиент для игры</h2>

<p>Итак, игрок <a href="/codenjoy-contest/register?gameName=tetris">
регистрируется на сервере</a>, указывая свой email</p>

<p>Далее необходимо подключиться <a href="../../../resources/tetris/user/clients.zip">из кода</a>
к серверу через вебсокеты. Это Maven проект и подойдет он для игры на JVM языках.
Как его запустить смотри в корне проекта в файле README.txt</p>

<p>Кроме того поддерживаются и другие языки программирования - их исходники находятся в том же архиве.</p>

<p>Адрес для подключения к игре на сервере, развернутом в локальной сети:</p>

<pre>ws://server_ip:8080/codenjoy-contest/ws?user=3edq63tw0bq4w4iem7nb&code=12345678901234567890</pre>

<p>Тут 'user' - id игрока, a 'code' - твой security token, его ты можешь получить из адресной
строки браузера после регистрации/логина</p>

<h2>Формат сообщений</h2>

<p>После подключения клиент будет регулярно (каждую секунду) получать строку
символов в формате JSON — с закодированным состоянием стакана. Формат таков:</p>

<pre>{
'currentFigurePoint':{'x':4,'y':9},
'currentFigureType':'O',
'futureFigures':['S', 'Z', 'I', 'O'],
'layers':[
'..................
........OO........
........OO........
..................
..................
..................
..................
..................
..................
..................
..................
..................
..................
..................
..I...............
..I......OO.......
..IOO..SSOOZZ.....
..IOO.SSIIIIZZ....'
]
}</pre>

<p>Параметр 'currentFigurePoint' содержит координату новой фигурки.
[0, 0] - левый нижний угол.</p>

<p>У каждой фигурки есть своя точка вращения</p>

<p><center><img src="img/rotate.png"></center></p>

<p>Параметр 'currentFigureType' содержит тип новой фигурки.</p>

<p>Параметр 'futureFigures' говорит о последующих фигурках,
которые появятся после текущей.</p>

<p>Параметр 'layers' содержит массив из одной строчки, которая содержит закодированное содержимое стакана.
Длинна строки 'layers[0]' равна площади поля (18 на 18 символов). Если вставить символ переноса
строки каждые sqrt(length(string)) символов, то получится читабельное
изображение стакана.</p>

<pre>..................
........OO........
........OO........
..................
..................
..................
..................
..................
..................
..................
..................
..................
..................
..................
..I...............
..I......OO.......
..IOO..SSOOZZ.....
..IOO.SSIIIIZZ....</pre>

<p><center><img src="img/glass.png"></center></p>

<p>Первый символ строки соответствует ячейке расположенной в левом верхнем
углу и имеет координату [0, 17].</p>

[Расшифровка символов](elements.md)

<h2>Команды управления</h2>

<p>Игра пошаговая, каждую секунду сервер посылает твоему клиенту (боту)
состояние обновленного стакана на текущий момент и ожидает ответа.
За следующую секунду алгоритм игрока должен успеть принять решение,
куда направить фигурку. Если алгоритм не успел — фигурка падает на 1 клетку вниз.</p>

<p>Команд несколько: LEFT, RIGHT – передвижение фигурки влево/вправо;<br>
DOWN - приземление фигурки;<br>
ACT - вращение фигурки по часовой стрелке на 90 градусов;<br>
ACT(2) - вращение на 180 градусов;<br>
ACT(3) - вращение против часовой стрелки на 90 градусов;<br>
ACT(0,0) - обнуление стакана (как и при его переполнении будут сняты штрафные очки).<br>
Команды движения/вращения/приземления можно комбинировать, разделяя их
через запятую – это значит что за один такт игры будет выполнена заданная цепочка команд.</p>

<h2>Начисление очков</h2>

<p>Всего предусмотрено несколько бонусных и одни штрафные очки.
За одну приземленную фигуру ты получаешь количество очков, равное ее сложности.
Считается, что самые простые фигурки - O (1 очко), затем I - 2 очка,
J - 3 очка, L - 4 очка, S - 5 очков, Z - 6 очков, T - 7 очков.
Фигуры будут появляться в этой последовательности с каждым новым уровнем все чаще.</p>

<p>За "снятые" линии ты будешь получать несравненно больше бонусных очков.
Причем, чем больше одновременно снятых линий - тем выгоднее.
Например за 1 "снятую" линию ты получишь 10*level очков,
за 2 "снятые" линии ты получишь уже 30*level очков,
за 3 "снятые" линии - 50*level очков,
за 4 "снятые" линии - 100*level очков. Тут level - уровень до которого ты дошел.</p>

<p>Так же не стоит забывать про штрафные очки. За каждый переполеннный стакан
(или если ты обнулишь его сам) ты потеряешь 10*level заработанных очков.
Победит тот участник, кто соберет больше всего очков за ограниченное количество времени.
За деталями обращайся к ведущему-Сенсею, вполне возможно, что эти константы,
а так же правила определения финалиста будут изменены.</p>

<h2>Клиент</h2>

<p>Но если <a href="../../../resources/tetris/user/clients.zip">клиент</a>
реализован на твоем языке программирования -
у тебя будет возможность использовать более высокоуровневое API:
Board - инкапсулирующий JSON состояние игры, и GlassBoard -
с полезными методами для анализа свободных и занятых мест в стакане;
и YourSolver - пустой класс одним методом - его тебе и
предстоит наполнить умной логикой. Ты так же можешь расширять
новыми методами на свое усмотрение классы Board и GlassBoard.</p>

<p>Прежде всего тебе предстоит выбрать язык программирования.
После открыть WebSocket клиент в IDE и запустить его.
Детали читай в Readme.txt в корне проекта.
Проследуя инструкциям ты подключишься к серверу.
Затем тебе предстоит заставить падающие фигурки слушаться твои команды,
вести осмысленную игру и победить.</p>

<h2>Хочешь провести ивент у себя?</h2>

<p>Игра с открытым исходным кодом. Для реализации своей игры, исправления
ошибок в текущей и внесения других правок необходимо для начала

<a href="https://github.com/codenjoyme/codenjoy">форкнуть проект</a>.
В корне репозитория есть описание в файле Readme.md - там описано, что делать дальше.</p>

<p>По возникающим вопросам, пиши в <a href="skype:alexander.baglay">skype:alexander.baglay</a>
или на почту <a href="mailto:apofig@gmail.com">apofig@gmail.com</a></p>

</div>
</div>